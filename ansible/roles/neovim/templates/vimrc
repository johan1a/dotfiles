" Don't emulate vi
set nocompatible
filetype off                  " required by Vundle

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

Plugin 'justinmk/vim-sneak'

Plugin 'majutsushi/tagbar'

Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-dispatch'

Plugin 'chriskempson/base16-vim'

Plugin 'git://github.com/godlygeek/tabular.git'

Plugin 'https://github.com/ctrlpvim/ctrlp.vim.git'

Plugin 'https://github.com/Shougo/deoplete.nvim.git'
Plugin 'https://github.com/clojure-vim/async-clj-omni.git'
Plugin 'https://github.com/zchee/deoplete-jedi.git'
Plugin 'artur-shaik/vim-javacomplete2'

Plugin 'udalov/kotlin-vim'

Plugin 'https://github.com/scrooloose/nerdtree.git'

" neosnippet makes the :intro message disappear for some reason
Plugin 'Shougo/neosnippet'
Plugin 'Shougo/neosnippet-snippets'

Plugin 'honza/vim-snippets'

Plugin 'dkprice/vim-easygrep'

Plugin 'LucHermitte/lh-vim-lib'
Plugin 'LucHermitte/lh-tags'
Plugin 'LucHermitte/lh-dev'
Plugin 'LucHermitte/lh-brackets'
Plugin 'LucHermitte/vim-refactor'

Plugin 'bbchung/gtags.vim'

Plugin 'ludovicchabant/vim-gutentags'
" :help gutentags

Plugin 'brookhong/cscope.vim'

" All of your Plugins must be added before the following line
call vundle#end()            " required
"  Brief help
" :PluginList       - lists configuredlugins
" :PluginInstall    - installslugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unusedlugins; append `!` to auto-approve removal

" see :h vundle for more details or wiki for FAQ
" Put your non-Plugin stuff after this line




" =========== deoplete ===========
" if :echo has("python3") returns 1, then you're done;
" Otherwise enable Python3 interface with pip:
" pip3 install --upgrade neovim
" :UpdateRemotePlugins and restart neovim

let g:deoplete#enable_at_startup = 1
if !exists('g:deoplete#omni#input_patterns')
  let g:deoplete#omni#input_patterns = {}
endif
let g:deoplete#disable_auto_complete = 1

" Enter: complete&close popup if visible (so next Enter works); else: break undo
inoremap <silent><expr> <Cr> pumvisible() ?
            \ deoplete#mappings#close_popup() : "<C-g>u<Cr>"

" deoplete tab-complete
inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"

" Ctrl-Space: summon FULL (synced) autocompletion
inoremap <silent><expr> <C-Space> deoplete#mappings#manual_complete()

" Escape: exit autocompletion, go to Normal mode
inoremap <silent><expr> <Esc> pumvisible() ? "<C-e><Esc>" : "<Esc>"

autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | pclose | endif

let g:deoplete#keyword_patterns = {}
let g:deoplete#keyword_patterns.clojure = '[\w!$%&*+/:<=>?@\^_~\-\.#]*'

" =========== neosnippet ===========

" Plugin key-mappings.
" Note: It must be "imap" and "smap".  It uses <Plug> mappings.

imap <expr><TAB>
 \ pumvisible() ? "\<C-n>" :
 \ neosnippet#expandable_or_jumpable() ?
 \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" For conceal markers.
if has('conceal')
  set conceallevel=2 concealcursor=niv
endif

" Enable snipMate compatibility feature.
let g:neosnippet#enable_snipmate_compatibility = 1

" Tell Neosnippet about the other snippets
" Does not seem to be working
let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets'


" If you want :UltiSnipsEdit to split your window.
"let g:UltiSnipsEditSplit="vertical"


" =========== ctrlp ===========
" Run :CtrlPClearAllCaches after changing this
let g:ctrlp_custom_ignore = '\v[\/](tags|node_modules|target|build$|dist|classes)|(\.(swp|ico|git|class|svn))$'

" Ignore files in .gitignore
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']

let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlPMixed'



nnoremap <c-o> :CtrlPTag<CR>


" =========== EasyGrep ===========
let g:EasyGrepFilesToExclude='*.log,tags,.git,external_documentation,documentation,build,classes'
let g:EasyGrepRecursive=1
let g:EasyGrepCommand=1

" =========== Gutentags =========

:set statusline+=%{gutentags#statusline('[Generating...]')}

" =========== tagbar =========

let g:tagbar_left=1

" =========== General settings ===========
syntax enable
filetype plugin indent on

" Automatically read external changes
set autoread
" Magic to make autoread actually work
" Trigger autoread when changing buffers while inside vim:
au FocusGained,BufEnter * :checktime
au CursorHold * checktime


if filereadable(expand("~/.vimrc_background"))
  let base16colorspace=256
  source ~/.vimrc_background
endif

" =========== filetypes ===========
au BufNewFile,BufRead *.gson setlocal ft=groovy


" =========== quickfix ===========

autocmd Filetype groovy setlocal makeprg=./gradlew\ test

" =========== vim-dispatch ===========

autocmd FileType java let b:dispatch = 'javac %'
autocmd FileType groovy let b:dispatch = 'source ~/.sdkman/bin/sdkman-init.sh && grails test-app'

nnoremap <leader>d :Dispatch<CR>

" =========== netrw ===========
" Enable netrw 'plugins'
filetype plugin on

" netrw tree view
let g:netrw_liststyle = 3

" Don't display info on the top of window
let g:netrw_banner = 0

" " sort is affecting only: directories on the top, files below
" let g:netrw_sort_sequence = '[\/]$,*'

" use the previous window to open file
let g:netrw_browse_split = 4

let g:netrw_altv = 1
let g:netrw_winsize = 25

" =========== search ===========

set grepprg=grep\ -nH\ $*

" Fuzzy finding
" :b <substring of open buffer> to jump to buffer
" :find <substring of open buffer>
set path+=**

" Tab completion behavior
set wildmode=longest,list,full
" Display all matches when tab completing
set wildmenu

" Leave margin when scrolling
set scrolloff=1
set sidescrolloff=5

set display+=lastline

" =========== ctags ===========
" Make tags. Requires ctags
command! MakeTags !ctags --extras=+r --fields=+r -R .

" =========== Splits ===========
:autocmd VimResized * wincmd =

" =========== Tabs and spaces  ===========
" insert space characters whenever the tab key is pressed,
set expandtab

" The number of space characters that will be inserted when the tab key is pressed
set tabstop=2

" The number of space characters inserted for indentation with the reindent
" operations (<< and >>)
set shiftwidth=2
set softtabstop=0

" Display tabs and trailing spaces
set list
set listchars=tab:▸–,trail:·
" Set color of listchars
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/

" =========== Numbering  ===========
set number

set relativenumber
set ruler

set showcmd

" =========== Key maps  ===========

" Remap leader
let mapleader =  "\<Space>"

"nnoremap <leader>f :find<space>

" ctrl+]        Jump to tag under cursor
nnoremap <leader>i <C-]>zz
" g+ctrl+]      List ambiguous tags
nnoremap <leader>a g<C-]>
" ctrl+t        Jump back up the tag stack
nnoremap <leader>u <C-t>zz

" ctrl+x is bound to tmux TODO
" ctr+x ctrl+n  just this file
" ctr+x ctrl+f  filenames
" ctr+x ctrl+]  tags only
" ctrl+n        autocomplete

" gf            open file under cursor

" "+y           copy to system clipboard
"
nnoremap <leader><leader> <C-^>

nnoremap <leader>m :MakeTags<CR>

" Reset search
nnoremap <leader>n :noh<CR>

" Reload config
nnoremap <leader>r :source ~/.vimrc<CR>

nnoremap <leader>h <C-W>H
nnoremap <leader>j <C-W>J
nnoremap <leader>k <C-W>K
nnoremap <leader>l <C-W>L
nnoremap <leader>o <C-W>r

" Toggle netrw
" nnoremap <leader>e :Lexplore<CR>

" Toggle NERDTree
" go previews
nnoremap <leader>e :NERDTreeToggle<CR>

nnoremap <leader>q :q<CR>

" ctrl+p
" <C-W><C-v> open in vertical split
" <C-W><C-x> open in horizontal split

" <C-o> older jump position
" <C-i> newer jump position

" Split navigation
nnoremap <A-j>  <C-W>j
nnoremap <A-k>  <C-W>k
nnoremap <A-h>  <C-W>h
nnoremap <A-l>  <C-W>l

" Increment / Decrement numbers
nnoremap <A-a> <C-a>
nnoremap <A-x> <C-x>

nnoremap ö {
nnoremap ä }

" replace and jump
nnoremap c* *Ncgn


" Yank from cursor to end of line
nnoremap Y y$

" Search using copy buffer

nnoremap <leader>7 /<C-R>0<CR>
nnoremap <leader>' ?<C-R>0<CR>


" Disable arrow keys
noremap <Up> <nop>
noremap <Down> <nop>
noremap <Left> <nop>
noremap <Right> <nop>

inoremap § <esc>
vnoremap § <esc>
noremap § <esc>
nnoremap § <esc>

" vim-refactor

vnoremap <leader>ef :ExtractFunction<space>
vnoremap <leader>ev :ExtractVariable<space>
vnoremap <leader>et :ExtractType<space>
vnoremap <leader>eg :ExtractGetter<space>
vnoremap <leader>es :ExtractSetter<space>
nnoremap <leader>p  i<C-X>p<CR>

" gtags

"nnoremap <leader>g  :Gtags<CR><CR>
"nnoremap <leader>f  :Gtags -r<CR><CR>
"nnoremap <leader>s  :Gtags -s<CR><CR>

" tagbar
nmap <leader>t :TagbarToggle<CR>

" cscope-vim
"
" Below is the minimum key mappings.

nnoremap <leader>fa :call CscopeFindInteractive(expand('<cword>'))<CR>
nnoremap <leader>l :call ToggleLocationList()<CR>
" Some optional key mappings to search directly.

" s: Find this C symbol
nnoremap  <leader>fs :call CscopeFind('s', expand('<cword>'))<CR>zz
" g: Find this definition
nnoremap  <leader>fg :call CscopeFind('g', expand('<cword>'))<CR>zz
" d: Find functions called by this function
nnoremap  <leader>fd :call CscopeFind('d', expand('<cword>'))<CR>zz
" c: Find functions calling this function
nnoremap  <leader>fc :call CscopeFind('c', expand('<cword>'))<CR>zz
" t: Find this text string
nnoremap  <leader>ft :call CscopeFind('t', expand('<cword>'))<CR>zz
" e: Find this egrep pattern
nnoremap  <leader>fe :call CscopeFind('e', expand('<cword>'))<CR>zz
" f: Find this file
nnoremap  <leader>ff :call CscopeFind('f', expand('<cword>'))<CR>zz
" i: Find files #including this file
nnoremap  <leader>fi :call CscopeFind('i', expand('<cword>'))<CR>zz




" vim-sneak
" 2-character Sneak (default)
nmap s <Plug>Sneak_s
nmap S <Plug>Sneak_S
" visual-mode
xmap s <Plug>Sneak_s
xmap S <Plug>Sneak_S
" operator-pending-mode
omap s <Plug>Sneak_s
omap S <Plug>Sneak_S

" repeat motion
map , <Plug>Sneak_;
map ; <Plug>Sneak_,

" 1-character enhanced 'f'
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
" visual-mode
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
" operator-pending-mode
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F

" 1-character enhanced 't'
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
" visual-mode
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
" operator-pending-mode
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

" force label-mode
nmap s <Plug>SneakLabel_s
nmap S <Plug>SneakLabel_S


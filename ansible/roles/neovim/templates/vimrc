
" Don't emulate vi
set nocompatible
filetype off                  " required by Vundle

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

Plugin 'leafgarland/typescript-vim'

Plugin 'airblade/vim-gitgutter'

Plugin 'christoomey/vim-tmux-navigator'

Plugin 'tpope/vim-fireplace'

Plugin 'justinmk/vim-sneak'

Plugin 'majutsushi/tagbar'

Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-dispatch'

Plugin 'chriskempson/base16-vim'

Plugin 'git://github.com/godlygeek/tabular.git'

Plugin 'https://github.com/ctrlpvim/ctrlp.vim.git'

Plugin 'https://github.com/Shougo/deoplete.nvim.git'
Plugin 'https://github.com/clojure-vim/async-clj-omni.git'
Plugin 'https://github.com/zchee/deoplete-jedi.git'
Plugin 'artur-shaik/vim-javacomplete2'

Plugin 'udalov/kotlin-vim'

Plugin 'https://github.com/scrooloose/nerdtree.git'

" neosnippet makes the :intro message disappear for some reason
" Plugin 'Shougo/neosnippet'
" Plugin 'Shougo/neosnippet-snippets'
" Plugin 'honza/vim-snippets'

Plugin 'dkprice/vim-easygrep'

Plugin 'ludovicchabant/vim-gutentags'
" :help gutentags

Plugin 'brookhong/cscope.vim'

Plugin 'bkad/CamelCaseMotion'

" All of your Plugins must be added before the following line
call vundle#end()            " required
"  Brief help
" :PluginList       - lists configuredlugins
" :PluginInstall    - installslugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unusedlugins; append `!` to auto-approve removal

" see :h vundle for more details or wiki for FAQ
" Put your non-Plugin stuff after this line

" =========== deoplete ===========
" if :echo has("python3") returns 1, then you're done;
" Otherwise enable Python3 interface with pip:
" pip3 install --upgrade neovim
" :UpdateRemotePlugins and restart neovim

let g:deoplete#enable_at_startup = 1
if !exists('g:deoplete#omni#input_patterns')
  let g:deoplete#omni#input_patterns = {}
endif
let g:deoplete#disable_auto_complete = 1

" Enter: complete&close popup if visible (so next Enter works); else: break undo
inoremap <silent><expr> <Cr> pumvisible() ?
            \ deoplete#mappings#close_popup() : "<C-g>u<Cr>"

" deoplete tab-complete
inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"

" Ctrl-Space: summon FULL (synced) autocompletion
inoremap <silent><expr> <C-Space> deoplete#mappings#manual_complete()

" Escape: exit autocompletion, go to Normal mode
inoremap <silent><expr> <Esc> pumvisible() ? "<C-e><Esc>" : "<Esc>"

augroup deoplete
    autocmd!
    autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | pclose | endif
augroup END


let g:deoplete#keyword_patterns = {}
let g:deoplete#keyword_patterns.clojure = '[\w!$%&*+/:<=>?@\^_~\-\.#]*'

" =========== neosnippet ===========

" Plugin key-mappings.
" Note: It must be "imap" and "smap".  It uses <Plug> mappings.

" imap <expr><TAB>
"  \ pumvisible() ? "\<C-n>" :
"  \ neosnippet#expandable_or_jumpable() ?
"  \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
" smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" For conceal markers.
if has('conceal')
  set conceallevel=2 concealcursor=niv
endif

" Enable snipMate compatibility feature.
" let g:neosnippet#enable_snipmate_compatibility = 1

" Tell Neosnippet about the other snippets
" Does not seem to be working
" let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets'


" If you want :UltiSnipsEdit to split your window.
"let g:UltiSnipsEditSplit="vertical"


" =========== ctrlp ===========
" Run :CtrlPClearAllCaches after changing this
let g:ctrlp_custom_ignore = '\v[\/](tags|node_modules|target|build$|dist|classes)|(\.(swp|ico|git|class|svn))$'

" Ignore files in .gitignore
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']

let g:ctrlp_map = '<c-b>'
let g:ctrlp_cmd = 'CtrlPMixed'

" =========== EasyGrep ===========
let g:EasyGrepFilesToExclude='*.log,tags,.git,external_documentation,documentation,build,classes'
let g:EasyGrepRecursive=1
let g:EasyGrepCommand=1

" =========== Gutentags =========

:set statusline+=%{gutentags#statusline('[Generating...]')}

" =========== tagbar =========

let g:tagbar_left=1

" =========== General settings ===========
syntax enable
filetype plugin indent on

" Automatically read external changes
set autoread
" Magic to make autoread actually work
" Trigger autoread when changing buffers while inside vim:
augroup general_settings
    autocmd!
    au FocusGained,BufEnter * :checktime
    au CursorHold * checktime
augroup END

if filereadable(expand('~/.vimrc_background'))
  let base16colorspace=256
  source ~/.vimrc_background
endif

" =========== filetypes ===========
augroup filetypes
  au BufNewFile,BufRead *.gson setlocal ft=groovy
  au BufNewFile,BufRead *.ts setlocal ft=typescript
augroup END

" =========== quickfix ===========

augroup quickfix
    autocmd!
    autocmd Filetype groovy setlocal makeprg=./gradlew\ test
augroup END

" =========== vim-dispatch ===========

augroup vim_dispatch
    autocmd!
    autocmd FileType java let b:dispatch = 'javac %'
    autocmd FileType groovy let b:dispatch = 'source ~/.sdkman/bin/sdkman-init.sh && grails test-app'
    autocmd FileType typescript let b:dispatch = 'ng test && ng lint'
augroup END

nnoremap <leader>m :Dispatch<CR>

" =========== search ===========

set grepprg=ag\ $*

nnoremap <leader>g :Grep

" Fuzzy finding
" :b <substring of open buffer> to jump to buffer
" :find <substring of open buffer>
set path+=**

" Tab completion behavior
set wildmode=longest,list,full

" Display all matches when tab completing
set wildmenu

" Leave margin when scrolling
set scrolloff=1
set sidescrolloff=5

set display+=lastline

" =========== Splits ===========
augroup splits
    autocmd!
    autocmd VimResized * wincmd =
augroup END

" =========== tmux-navigator ===========

" Disable tmux auto zoom out
let g:tmux_navigator_disable_when_zoomed = 1

" =========== Tabs and spaces  ===========
" insert space characters whenever the tab key is pressed,
set expandtab

" The number of space characters that will be inserted when the tab key is pressed
set tabstop=2

" The number of space characters inserted for indentation with the reindent
" operations (<< and >>)
set shiftwidth=2
set softtabstop=0

" Display tabs and trailing spaces
set list
set listchars=tab:▸–,trail:·
" Set color of listchars
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/

" =========== Numbering  ===========
set number
set relativenumber
set ruler
set showcmd

" =========== Key maps  ===========

" Remap leader
let mapleader =  "\<Space>"

"nnoremap <leader>f :find<space>

" ctrl+]        Jump to tag under cursor
nnoremap <leader>i <C-]>zz
" g+ctrl+]      List ambiguous tags
nnoremap <leader>a g<C-]>
" ctrl+t        Jump back up the tag stack
nnoremap <leader>u <C-t>zz

" ctrl+x is bound to tmux TODO
" ctr+x ctrl+n  just this file
" ctr+x ctrl+f  filenames
" ctr+x ctrl+]  tags only
" ctrl+n        autocomplete

" gf            open file under cursor

" "+y           copy to system clipboard
"
nnoremap <leader><leader> <C-^>

"nnoremap <leader>m :MakeTags<CR>

" Reset search
nnoremap <leader>n :noh<CR>

" Reload config
nnoremap <leader>r :source ~/.vimrc<CR>

nnoremap <a-h> <C-W>H
nnoremap <a-j> <C-W>J
nnoremap <a-k> <C-W>K
nnoremap <a-l> <C-W>L
nnoremap <a-o> <C-W>r

" Toggle NERDTree
" go previews
nnoremap <leader>e :NERDTreeToggle<CR>

nnoremap <leader>q :q<CR>

" ctrl+p
" <C-W><C-v> open in vertical split
" <C-W><C-x> open in horizontal split

" <C-o> older jump position
" <C-i> newer jump position

" Increment / Decrement numbers
nnoremap <A-a> <C-a>
nnoremap <A-x> <C-x>

nnoremap ö {
nnoremap ä }

" replace and jump
nnoremap c* *Ncgn

" Copy / Paste

" Yank from cursor to end of line
nnoremap Y y$

" Search using copy buffer

nnoremap <leader>7 /<C-R>0<CR>
nnoremap <leader>' ?<C-R>0<CR>

" ALWAYS use the clipboard for ALL operations (as opposed
" to interacting with the '+' and/or '*' registers explicitly):

set clipboard+=unnamedplus

" Use system copy buffer

nnoremap y "*y
vnoremap y "*y
nnoremap p "*p
vnoremap p "*p
vnoremap c "*c
nnoremap c "*c
vnoremap C "*C
nnoremap C "*C
nnoremap d "*d
vnoremap d "*d
"noremap <leader>p :set paste<CR>:put *<CR>:set nopaste<CR>


" Disable arrow keys
noremap <Up> <nop>
noremap <Down> <nop>
noremap <Left> <nop>
noremap <Right> <nop>

inoremap § <esc>
vnoremap § <esc>
noremap § <esc>
nnoremap § <esc>

" tagbar
nmap <a-t> :TagbarToggle<CR>

" cscope-vim
" Below is the minimum key mappings.

let g:cscope_silent = 1

nnoremap <leader>fa :call CscopeFindInteractive(expand('<cword>'))<CR>
nnoremap <leader>fl :call ToggleLocationList()<CR>
" Some optional key mappings to search directly.

" s: Find this C symbol
nnoremap  <leader>fs :call CscopeFind('s', expand('<cword>'))<CR>zz
" g: Find this definition
nnoremap  <leader>fg :call CscopeFind('g', expand('<cword>'))<CR>zz
" d: Find functions called by this function
nnoremap  <leader>fd :call CscopeFind('d', expand('<cword>'))<CR>zz
" c: Find functions calling this function
nnoremap  <leader>fc :call CscopeFind('c', expand('<cword>'))<CR>zz
" t: Find this text string
nnoremap  <leader>ft :call CscopeFind('t', expand('<cword>'))<CR>zz
" e: Find this egrep pattern
nnoremap  <leader>fe :call CscopeFind('e', expand('<cword>'))<CR>zz
" f: Find this file
nnoremap  <leader>ff :call CscopeFind('f', expand('<cword>'))<CR>zz
" i: Find files #including this file
nnoremap  <leader>fi :call CscopeFind('i', expand('<cword>'))<CR>zz

" vim-sneak
" 2-character Sneak (default)
" nmap s <Plug>Sneak_s
" nmap S <Plug>Sneak_S
" visual-mode
" xmap s <Plug>Sneak_s
" xmap S <Plug>Sneak_S
" operator-pending-mode
" omap s <Plug>Sneak_s
" omap S <Plug>Sneak_S

" repeat motion
map , <Plug>Sneak_;
map ; <Plug>Sneak_,

" 1-character enhanced 'f'
nmap s <Plug>SneakLabel_s
nmap S <Plug>SneakLabel_S
" visual-mode
xmap s <Plug>SneakLabel_s
xmap S <Plug>SneakLabel_S
" operator-pending-mode
omap s <Plug>SneakLabel_s
omap S <Plug>SneakLabel_S

" vim-fireplace

nnoremap <leader>w :Eval<CR>
vnoremap <leader>w :Eval<CR>

nnoremap <a-r> :Require<CR>

" CamelCaseMotion

" Map to w, b and e mappings:

map <silent> w <Plug>CamelCaseMotion_w
map <silent> b <Plug>CamelCaseMotion_b
map <silent> e <Plug>CamelCaseMotion_e
map <silent> ge <Plug>CamelCaseMotion_ge
sunmap w
sunmap b
sunmap e
sunmap ge


" neovim term

tnoremap <C-o> <C-\><C-n>

tnoremap <leader><esc> <C-\><esc>

"To simulate |i_CTRL-R| in terminal-mode:
"    :tnoremap <expr> <C-R> '<C-\><C-N>"'.nr2char(getchar()).'pi'

"To use `ALT+{h,j,k,l}` to navigate windows from any mode:
tnoremap <C-h> <C-\><C-N><C-w>h
tnoremap <C-j> <C-\><C-N><C-w>j
tnoremap <C-k> <C-\><C-N><C-w>k
tnoremap <C-l> <C-\><C-N><C-w>l
inoremap <C-h> <C-\><C-N><C-w>h
inoremap <C-j> <C-\><C-N><C-w>j
inoremap <C-k> <C-\><C-N><C-w>k
inoremap <C-l> <C-\><C-N><C-w>l

" Execute a shell command and read in the results
noremap Q !!$SHELL<CR>

" Tabs and splits
nnoremap <a-l> :tabn<cr>
nnoremap <a-h> :tabp<cr>
nnoremap <leader>b :tabe<cr>
nnoremap <leader>j :tabe<cr>:term<cr>

nnoremap <leader>s :sp<cr>
nnoremap <leader>t :vs<cr>
